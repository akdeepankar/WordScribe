import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs))
}

export function textToDigits(text: string): string {
    const numberMap: { [key: string]: string } = {
        'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',
        'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9',
        'ten': '10', 'eleven': '11', 'twelve': '12', 'thirteen': '13',
        'fourteen': '14', 'fifteen': '15', 'sixteen': '16', 'seventeen': '17',
        'eighteen': '18', 'nineteen': '19', 'twenty': '20'
    };

    return text.split(/[\s-]+/).map(word => {
        const lower = word.toLowerCase().replace(/[^a-z]/g, '');
        return numberMap[lower] || word;
    }).join(' ');
}

export interface ScribeEntity {
    entity_type: string;
    text: string;
    start_char: number;
    end_char: number;
}

export interface ScribeWord {
    text: string;
    start: number;
    end: number;
    type: string;
}

export interface MappedEntity extends ScribeEntity {
    timestamp: number;
    formattedTimestamp: string;
}

export const mapEntitiesToTimestamps = (entities: ScribeEntity[], words: ScribeWord[]): MappedEntity[] => {
    if (!entities || !words) return [];

    let currentLength = 0;
    const wordMap = words.map(w => {
        const startChar = currentLength;
        currentLength += w.text.length;
        return { ...w, startChar, endChar: currentLength };
    });

    return entities.map(entity => {
        const match = wordMap.find(w => w.startChar <= entity.start_char && w.endChar > entity.start_char) ||
            wordMap.find(w => w.endChar > entity.start_char);

        const seconds = match ? match.start : 0;

        const date = new Date(seconds * 1000);
        const mm = date.getUTCMinutes().toString().padStart(2, '0');
        const ss = date.getUTCSeconds().toString().padStart(2, '0');

        return {
            ...entity,
            timestamp: seconds,
            formattedTimestamp: `${mm}:${ss}`
        };
    });
};

export function downloadFile(content: string, filename: string, type: string) {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

export function generateShowNotes(title: string, data: any): string {
    return `# ${title}
    
## Summary
${data.highlights.slice(0, 3).map((h: any) => `- ${h.text}`).join('\n')}

## Timestamps
${data.chapters.map((c: any) => `- ${c.timestamp} ${c.title}`).join('\n')}

## Key Highlights
${data.highlights.map((h: any) => `> "${h.text}"`).join('\n\n')}

## Q&A
${data.qa.map((q: any) => `**Q: ${q.question}**\nA: ${q.answer}`).join('\n\n')}

## Sponsors
${data.sponsors.length > 0 ? data.sponsors.map((s: any) => `- ${s.text}`).join('\n') : "No sponsors detected."}

---
Generated by WordScribe
`;
}

export function getYouTubeId(url: string): string | null {
    if (!url) return null;
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
}

export function cleanEntityText(text: string): string {
    // 1. Check if text is spelled out (e.g. "R-A-N-D-A-L-L")
    // If it looks like single uppercase letters separated by hyphens or spaces
    const spelledOutRegex = /^([A-Z][-\s]){2,}[A-Z]$/i;
    if (spelledOutRegex.test(text)) {
        return text.replace(/[-\s]/g, '');
    }

    // 2. Remove standard noise
    return text.replace(/[\.-]/g, '').replace(/\s+/g, ' ').trim();
}
